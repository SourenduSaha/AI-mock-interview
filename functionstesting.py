# -*- coding: utf-8 -*-
"""functionstesting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VOnj8d7hl-P8mdfFk5BJSJetsp3j2-6v
"""

import os
os.environ["OPENAI_API_KEY"] = "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"

!pip install PyPDF2 python-docx pandas openai

import os
import re
import json
import time
from openai import OpenAI

# File handling libraries
import docx
import pandas as pd
from PyPDF2 import PdfReader

#----------------------------------------
# FILE READING UTILITIES
#----------------------------------------

def read_file(file_path):
    """Generic function to read file content based on extension"""
    try:
        # Determine file type based on extension
        file_extension = os.path.splitext(file_path)[1].lower()

        # Read the file content based on type
        if file_extension == '.pdf':
            return read_pdf(file_path)
        elif file_extension == '.docx':
            return read_docx(file_path)
        elif file_extension == '.txt':
            with open(file_path, 'r', encoding='utf-8') as file:
                return file.read()
        elif file_extension in ['.csv', '.xlsx', '.xls']:
            # For tabular formats, convert to text representation
            return read_tabular(file_path)
        else:
            # Try to read as text for unknown file types
            with open(file_path, 'r', encoding='utf-8') as file:
                return file.read()
    except Exception as e:
        print(f"Error reading file {file_path}: {str(e)}")
        return f"Could not read file {file_path}"

def read_pdf(pdf_path):
    """Extract text from PDF file"""
    try:
        reader = PdfReader(pdf_path)
        text = ""
        for page in reader.pages:
            text += page.extract_text() + "\n"
        return text
    except Exception as e:
        print(f"Error reading PDF: {str(e)}")
        return ""

def read_docx(docx_path):
    """Extract text from DOCX file"""
    try:
        doc = docx.Document(docx_path)
        text = []
        for paragraph in doc.paragraphs:
            text.append(paragraph.text)
        return "\n".join(text)
    except Exception as e:
        print(f"Error reading DOCX: {str(e)}")
        return ""

def read_tabular(file_path):
    """Extract text representation from tabular files (CSV, Excel)"""
    try:
        extension = os.path.splitext(file_path)[1].lower()
        if extension == '.csv':
            df = pd.read_csv(file_path)
        else:  # Excel formats
            df = pd.read_excel(file_path)

        # Convert DataFrame to text representation
        text = "Resume in tabular format:\n\n"
        for col in df.columns:
            text += f"{col}:\n"
            for val in df[col].dropna():
                text += f"- {val}\n"
            text += "\n"

        return text
    except Exception as e:
        print(f"Error reading tabular file: {str(e)}")
        return ""

#----------------------------------------
# RESUME PARSING
#----------------------------------------

def parse_resume_with_ai(resume_text):
    """Use AI to extract structured information from resume text"""
    try:
        client = OpenAI()

        prompt = f"""
        Extract structured information from the following resume:

        {resume_text}

        Return the information in this JSON format:
        {{
            "contact_info": {{
                "name": "",
                "email": "",
                "phone": "",
                "location": ""
            }},
            "summary": "",
            "education": [
                {{
                    "degree": "",
                    "institution": "",
                    "dates": "",
                    "gpa": "",
                    "details": []
                }}
            ],
            "experience": [
                {{
                    "title": "",
                    "company": "",
                    "dates": "",
                    "location": "",
                    "responsibilities": []
                }}
            ],
            "skills": {{
                "technical": [],
                "soft": [],
                "languages": [],
                "tools": []
            }},
            "projects": [
                {{
                    "name": "",
                    "description": "",
                    "technologies": [],
                    "outcomes": []
                }}
            ],
            "certifications": [],
            "years_of_experience": 0,
            "domain_expertise": []
        }}

        If a field can't be determined from the resume, use null or an empty array as appropriate.
        For "years_of_experience", determine the total years of professional experience based on work history.
        For "domain_expertise", identify industry domains where the candidate has experience.
        """

        messages = [
            {"role": "system", "content": "You are an expert resume parser. Extract structured information from resumes accurately."},
            {"role": "user", "content": prompt}
        ]

        start = time.time()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            response_format={"type": "json_object"}
        )
        end = time.time()

        structured_resume = json.loads(response.choices[0].message.content)
        print(f"Resume parsed in {round(end - start, 2)} seconds")

        return structured_resume

    except Exception as e:
        print(f"Error parsing resume with AI: {str(e)}")
        return {
            "contact_info": {},
            "education": [],
            "experience": [],
            "skills": {},
            "years_of_experience": 0,
            "domain_expertise": []
        }

def extract_resume_structure(resume_path):
    """Extract structured information from a resume file"""
    try:
        # Read the file content
        resume_text = read_file(resume_path)
        print(f"Successfully read resume from {resume_path}")

        # Use OpenAI to extract structured information
        structured_resume = parse_resume_with_ai(resume_text)
        return structured_resume

    except Exception as e:
        print(f"Error extracting resume structure: {str(e)}")
        # Return a minimal structure if parsing fails
        return {
            "contact_info": {},
            "education": [],
            "experience": [],
            "skills": [],
            "full_text": "Could not parse resume"
        }

#----------------------------------------
# JOB DESCRIPTION PARSING
#----------------------------------------

def extract_job_description_structure(jd_path):
    """Extract structured information from job description file"""
    try:
        # Read the file content
        jd_text = read_file(jd_path)
        print(f"Successfully read job description from {jd_path}")

        # Use AI to extract structured information
        client = OpenAI()

        prompt = f"""
        Extract structured information from the following job description:

        {jd_text}

        Return the information in this JSON format:
        {{
            "title": "",
            "company": "",
            "location": "",
            "employment_type": "",
            "summary": "",
            "responsibilities": [],
            "requirements": {{
                "required_skills": [],
                "preferred_skills": [],
                "education": [],
                "experience": []
            }},
            "benefits": [],
            "industry": "",
            "seniority_level": "",
            "key_technologies": []
        }}

        If a field can't be determined from the job description, use null or an empty array as appropriate.
        For "industry", identify the industry sector this role belongs to.
        For "seniority_level", determine if this is entry-level, mid-level, senior, or executive.
        For "key_technologies", identify specific technologies, tools, or platforms mentioned as requirements.
        """

        messages = [
            {"role": "system", "content": "You are an expert job description parser. Extract structured information from job descriptions accurately."},
            {"role": "user", "content": prompt}
        ]

        start = time.time()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            response_format={"type": "json_object"}
        )
        end = time.time()

        structured_jd = json.loads(response.choices[0].message.content)
        print(f"Job description parsed in {round(end - start, 2)} seconds")

        return structured_jd

    except Exception as e:
        print(f"Error parsing job description: {str(e)}")
        return {
            "title": "",
            "company": "",
            "responsibilities": [],
            "requirements": {"required_skills": []},
            "industry": "",
            "seniority_level": ""
        }

def analyze_resume_job_alignment(structured_resume, structured_jd):
    """Analyze the alignment between resume and job description"""
    try:
        client = OpenAI()

        # Prepare the input for analysis
        resume_json = json.dumps(structured_resume, indent=2)
        jd_json = json.dumps(structured_jd, indent=2)

        prompt = f"""
        Analyze the alignment between this candidate's resume and the job description:

        RESUME:
        {resume_json}

        JOB DESCRIPTION:
        {jd_json}

        Provide a JSON analysis with the following structure:
        {{
            "overall_match_score": 0-100,
            "skill_match": {{
                "score": 0-100,
                "matching_skills": [],
                "missing_skills": []
            }},
            "experience_match": {{
                "score": 0-100,
                "relevant_experience": [],
                "experience_gaps": []
            }},
            "education_match": {{
                "score": 0-100,
                "comments": ""
            }},
            "strengths": [],
            "areas_of_concern": [],
            "suggested_interview_focus_areas": []
        }}

        Base your analysis on how well the candidate's qualifications align with the job requirements.
        """

        messages = [
            {"role": "system", "content": "You are an expert resume analyzer with deep knowledge of job requirements and candidate evaluation."},
            {"role": "user", "content": prompt}
        ]

        start = time.time()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            response_format={"type": "json_object"}
        )
        end = time.time()

        alignment_analysis = json.loads(response.choices[0].message.content)
        print(f"Resume-job alignment analyzed in {round(end - start, 2)} seconds")

        return alignment_analysis

    except Exception as e:
        print(f"Error analyzing resume-job alignment: {str(e)}")
        return {
            "overall_match_score": 50,
            "strengths": ["Could not perform detailed analysis"],
            "areas_of_concern": ["Could not perform detailed analysis"],
            "suggested_interview_focus_areas": ["Technical skills", "Experience", "Problem-solving"]
        }

#----------------------------------------
# QUESTION GENERATION
#----------------------------------------

def create_personal_profile(structured_resume, structured_jd):
    """Create a personal profile from structured resume and job description"""
    profile = {
        'name': structured_resume.get('contact_info', {}).get('name', 'Candidate'),
        'role': structured_jd.get('title', 'Data Scientist'),
        'company': structured_jd.get('company', 'Company'),
        'industry': structured_jd.get('industry', 'Technology'),
        'experience': structured_resume.get('years_of_experience', '3-5'),
        'education': [edu.get('degree', '') + ' from ' + edu.get('institution', '')
                     for edu in structured_resume.get('education', [])],
        'skills': {
            'technical': structured_resume.get('skills', {}).get('technical', []),
            'soft': structured_resume.get('skills', {}).get('soft', [])
        },
        'domain_expertise': structured_resume.get('domain_expertise', []),
        'job_requirements': structured_jd.get('requirements', {}).get('required_skills', []),
        'job_responsibilities': structured_jd.get('responsibilities', []),
        'key_technologies': structured_jd.get('key_technologies', []),
        'seniority_level': structured_jd.get('seniority_level', 'Mid-level')
    }

    # Create a skill match score
    required_skills = set([skill.lower() for skill in profile['job_requirements']])
    candidate_skills = set([skill.lower() for skill in profile['skills']['technical']])

    if required_skills:
        profile['skill_match_score'] = len(required_skills.intersection(candidate_skills)) / len(required_skills)
    else:
        profile['skill_match_score'] = 0

    return profile

def generate_initial_question(structured_resume, structured_jd):
    """Generate the initial interview question based on structured resume and job description"""
    # Prepare resume and job description in a structured format
    resume_summary = {
        "name": structured_resume.get("contact_info", {}).get("name", ""),
        "experience": [
            {
                "title": exp.get("title", ""),
                "company": exp.get("company", ""),
                "responsibilities": exp.get("responsibilities", [])[:3]  # Limit to 3 responsibilities
            } for exp in structured_resume.get("experience", [])[:3]  # Limit to 3 most recent experiences
        ],
        "education": [
            {
                "degree": edu.get("degree", ""),
                "institution": edu.get("institution", "")
            } for edu in structured_resume.get("education", [])
        ],
        "skills": structured_resume.get("skills", {}),
        "projects": [proj.get("name", "") for proj in structured_resume.get("projects", [])[:3]]
    }

    jd_summary = {
        "title": structured_jd.get("title", ""),
        "company": structured_jd.get("company", ""),
        "responsibilities": structured_jd.get("responsibilities", [])[:5],  # Limit to 5 key responsibilities
        "required_skills": structured_jd.get("requirements", {}).get("required_skills", []),
        "industry": structured_jd.get("industry", "")
    }

    # Convert to JSON strings
    resume_json = json.dumps(resume_summary, indent=2)
    jd_json = json.dumps(jd_summary, indent=2)

    # Prepare messages
    messages = [
        {"role": "system", "content": "You are an expert AI interviewer for data science roles."},
        {"role": "user", "content": f"""
Given the structured resume and job description below, generate 1 thoughtful and role-specific technical interview question.

STRUCTURED RESUME:
{resume_json}

STRUCTURED JOB DESCRIPTION:
{jd_json}

Guidelines for your question:
1. Be specific to the candidate's background and the job requirements
2. Focus on technical knowledge and practical application
3. Target skills or experiences that appear most relevant for this role
4. Keep the question under 30 words and end with a question mark
5. Make it conversational but substantive
"""}
    ]

    # Call OpenAI API
    client = OpenAI()

    start = time.time()
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=messages
    )
    end = time.time()

    initial_question = response.choices[0].message.content
    print(f"\nInitial Question:\n{initial_question}")
    print(f"Took {round(end - start, 2)} seconds\n")

    return initial_question, messages

def generate_follow_up_questions(messages):
    """Generate follow-up questions based on the initial question"""
    messages.append({"role": "user", "content": f"""
Based on the initial interview question generated above, generate 3 additional follow-up questions that are related to those questions.
Each question should:
1. Be clearly distinct from the others
2. Probe different aspects of the candidate's knowledge and experience
3. Follow a logical progression of complexity
4. Be specific to the data science role indicated in the context
5. Be formatted as numbered questions (1., 2., 3.)
"""})

    client = OpenAI()

    start = time.time()
    followup_response = client.chat.completions.create(
        model="gpt-4o",
        messages=messages
    )
    end = time.time()

    follow_up_questions = followup_response.choices[0].message.content
    print(f"Generated follow-up questions:\n{follow_up_questions}")
    print(f"Took {round(end - start, 2)} seconds\n")

    # Extract the questions from the response
    questions = []
    for line in follow_up_questions.strip().split('\n'):
        if re.match(r'^\d+\.', line.strip()):
            questions.append(line.strip())

    return questions

def generate_tailored_questions(personal_profile):
    """Generate interview questions tailored to the candidate's background and role"""
    try:
        client = OpenAI()

        prompt = f"""
        Generate 5 tailored technical interview questions for a {personal_profile['role']} position based on the candidate's background:

        Candidate Profile:
        - Experience: {personal_profile['experience']} years
        - Education: {', '.join(personal_profile['education'])}
        - Technical Skills: {', '.join(personal_profile['skills']['technical'][:10])}
        - Domain Expertise: {', '.join(personal_profile['domain_expertise'])}

        Job Requirements:
        - Role: {personal_profile['role']} at {personal_profile['company']}
        - Industry: {personal_profile['industry']}
        - Seniority: {personal_profile['seniority_level']}
        - Key Technologies: {', '.join(personal_profile['key_technologies'])}
        - Key Responsibilities: {', '.join(personal_profile['job_responsibilities'][:3])}

        Generate 5 different types of questions:
        1. A technical knowledge question about a key technology required for the role
        2. A problem-solving question related to the industry challenges
        3. A scenario-based question about handling a specific job responsibility
        4. A question about a project mentioned in their background related to the job requirements
        5. A question that tests the candidate's understanding of how their skills apply to the company's industry

        Each question should:
        - Be specific to this candidate and role (not generic)
        - Be 1-2 sentences long
        - Probe for both knowledge and applied experience
        - Not require external resources to answer
        - End with a question mark

        Format each question as:
        "1. [Technical Knowledge] Question text"
        "2. [Problem Solving] Question text"
        etc.
        """

        messages = [
            {"role": "system", "content": "You are an expert technical interviewer for data science roles, with deep knowledge of industry best practices and technical requirements."},
            {"role": "user", "content": prompt}
        ]

        start = time.time()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages
        )
        end = time.time()

        questions = response.choices[0].message.content.strip().split("\n")
        print(f"Generated {len(questions)} tailored questions in {round(end - start, 2)} seconds")

        # Filter out any non-question lines and clean up formatting
        filtered_questions = []
        for question in questions:
            # Check if line starts with a number and contains a question mark
            if re.match(r'^\d+\.', question) and '?' in question:
                # Extract the question text, removing the category label if present
                question_text = re.sub(r'^\d+\.\s+\[[^\]]+\]\s+', '', question)
                filtered_questions.append(question_text)

        return filtered_questions

    except Exception as e:
        print(f"Error generating tailored questions: {str(e)}")
        return [
            "Tell me about your experience with data science projects.",
            "How would you approach a classification problem?",
            "What programming languages are you most comfortable with?",
            "Describe a challenging data problem you've solved.",
            "How do you stay updated with the latest developments in data science?"
        ]

def generate_dynamic_question(messages, user_response, personal_profile=None):
    """Generate a dynamic follow-up question based on the user's response"""
    # Add the user's response to the conversation
    messages.append({"role": "user", "content": user_response})

    # Fall back to OpenAI directly
    print("Generating dynamic follow-up question")

    client = OpenAI()

    # Create a new system message with profile context if available
    profile_context = ""
    if personal_profile:
        profile_context = f"""
        Candidate Profile:
        - Name: {personal_profile.get('name', 'Candidate')}
        - Role applying for: {personal_profile.get('role', 'Data Science Role')}
        - Experience level: {personal_profile.get('experience', 'Unknown')} years
        - Technical skills: {', '.join(personal_profile.get('skills', {}).get('technical', [])[:5])}
        - Background: {', '.join(personal_profile.get('domain_expertise', []))}
        """

    system_message = {
        "role": "system",
        "content": f"""
            You are an expert technical interviewer for data science roles.
            {profile_context}
            Generate a thoughtful follow-up question based on the candidate's response.
            The question should:
            1. Dig deeper into a specific aspect mentioned by the candidate
            2. Be conversational but technically substantive
            3. Be no longer than 30 words
            4. End with a question mark
        """
    }

    # Create a new messages array with the system message first
    formatted_messages = [system_message] + messages

    start = time.time()
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=formatted_messages,
        temperature=0.2
    )
    end = time.time()

    follow_up_question = response.choices[0].message.content
    print(f"\nDynamic Follow-Up Question: {follow_up_question}")
    print(f"Took {round(end - start, 2)} seconds\n")

    return follow_up_question

#----------------------------------------
# ANSWER EVALUATION
#----------------------------------------

def generate_expert_answer(question, personal_profile=None):
    """Generate an expert answer to the interview question"""
    # Simplified version without RAG, just using OpenAI directly
    print("Generating expert answer")
    client = OpenAI()

    profile_context = ""
    if personal_profile:
        profile_context = f"""
        Answer as if you are a candidate with this profile:
        - Experience: {personal_profile.get('experience', '5+')} years in {personal_profile.get('role', 'data science')}
        - Education: {', '.join(personal_profile.get('education', ['Advanced degree in a relevant field']))}
        - Technical Skills: {', '.join(personal_profile.get('skills', {}).get('technical', [])[:7])}
        - Domain Expertise: {', '.join(personal_profile.get('domain_expertise', ['data analytics']))}
        - Industry: {personal_profile.get('industry', 'technology')}
        """

    template = f"""
    You are an experienced data scientist in a job interview. Answer the following question naturally as if speaking to the interviewer.

    {profile_context}

    Question: {question}

    Guidelines for your response:
    - Speak in first person ("I", "my", "we")
    - Use natural transitions and connecting phrases
    - Keep it concise (150-200 words)
    - Include a brief opening statement that directly answers the question
    - Follow with a technical explanation using correct terminology
    - Share a specific example if possible
    - Conclude with the business impact or practical application

    Response style:
    - Conversational and engaging, as if speaking in person
    - Professional but approachable
    - Show both technical expertise and communication skills
    - Avoid formal documentation style or academic tone
    - No bullet points or formatting - use natural speech flow
    """

    messages = [
        {"role": "system", "content": "You are an experienced data scientist in a job interview."},
        {"role": "user", "content": template}
    ]

    response = client.chat.completions.create(
        model="gpt-4o",
        messages=messages,
        temperature=0.1,
        max_tokens=2000
    )

    return response.choices[0].message.content

def evaluate_answer(user_answer, expert_answer, question, audio_features=None, text_features=None):
    """Evaluate the user's answer compared to the expert answer"""

    evaluation_prompt = f"""
    You are an expert interviewer and evaluator for data science roles. Compare the candidate's answer to an expert reference answer for the same question.

    Question: {question}

    Candidate's Answer: {user_answer}

    Expert Reference Answer: {expert_answer}

    Audio Features: {audio_features if audio_features else 'Not available'}

    Text Features: {text_features if text_features else 'Not available'}

    Evaluate the candidate's answer on the following criteria:
    1. Technical Accuracy (0-10): How well does the answer demonstrate understanding of technical concepts?
    2. Relevance (0-10): How directly does the answer address the question asked?
    3. Depth (0-10): How well does the answer explore the topic beyond surface level?
    4. Communication (0-10): How clear, concise, and well-structured is the answer?
    5. Practical Application (0-10): How well does the answer connect to real-world applications?

    For each criterion, provide:
    - A numerical score
    - 1-2 sentences of specific feedback
    - A specific improvement suggestion

    Then provide an Overall Score (0-100) and 2-3 sentences of summary feedback.
    """

    client = OpenAI()

    messages = [
        {"role": "system", "content": "You are an expert AI interviewer and evaluator for data science roles."},
        {"role": "user", "content": evaluation_prompt}
    ]

    try:
        start = time.time()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages
        )
        end = time.time()

        evaluation = response.choices[0].message.content
        print(f"\nAnswer Evaluation:\n{evaluation}")
        print(f"Took {round(end - start, 2)} seconds\n")

        return evaluation
    except Exception as e:
        print(f"Error evaluating answer: {str(e)}")
        return "Could not evaluate the answer due to an error."

def get_interview_summary(interview_data):
    """Generate a summary of the interview with feedback"""
    client = OpenAI()

    # Format interview data
    interview_transcript = ""
    for i, q_data in enumerate(interview_data):
        question = q_data.get("question", "")
        answer = q_data.get("answer", "")
        evaluation = q_data.get("evaluation", "")

        interview_transcript += f"Q{i+1}: {question}\n\n"
        interview_transcript += f"A{i+1}: {answer}\n\n"
        interview_transcript += f"Evaluation: {evaluation}\n\n"
        interview_transcript += "---\n\n"

    summary_prompt = f"""
    You are an expert interviewer for data science roles. Analyze the complete interview below and provide a comprehensive summary with feedback.

    Interview for Data Science Role:

    {interview_transcript}

    Please provide:
    1. Overall Assessment: Give a 2-3 paragraph summary of the candidate's performance
    2. Key Strengths: List 3-5 specific strengths demonstrated in the interview
    3. Areas for Improvement: List 2-3 specific areas where the candidate could improve
    4. Technical Competency: Rate the candidate's technical knowledge (1-10) with brief explanation
    5. Communication Skills: Rate the candidate's communication skills (1-10) with brief explanation
    6. Recommendation: Provide a clear hiring recommendation (Strongly Recommend, Recommend, Consider, or Do Not Recommend)
    """

    messages = [
        {"role": "system", "content": "You are an expert AI interviewer and evaluator for data science roles."},
        {"role": "user", "content": summary_prompt}
    ]

    try:
        start = time.time()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages
        )
        end = time.time()

        interview_summary = response.choices[0].message.content
        print(f"\nInterview Summary:\n{interview_summary}")
        print(f"Took {round(end - start, 2)} seconds\n")

        return interview_summary
    except Exception as e:
        print(f"Error generating interview summary: {str(e)}")
        return "Could not generate interview summary due to an error."

#----------------------------------------
# INTERVIEW SESSION CLASS
#----------------------------------------

class InterviewSession:
    def __init__(self, resume_path, job_description_path):
        # Parse resume and job description
        self.resume_text = read_file(resume_path)
        self.job_description_text = read_file(job_description_path)

        # Extract structured information
        self.structured_resume = extract_resume_structure(resume_path)
        self.structured_jd = extract_job_description_structure(job_description_path)

        # Create personal profile from structured information
        self.personal_profile = create_personal_profile(self.structured_resume, self.structured_jd)

        # Initialize interview state
        self.interview_data = []
        self.current_question_idx = 0
        self.messages = []
        self.current_question = None

        # Analyze resume-job alignment
        self.alignment_analysis = analyze_resume_job_alignment(self.structured_resume, self.structured_jd)

    def start_interview(self):
        """Start the interview with the initial question"""
        initial_question, self.messages = generate_initial_question(self.structured_resume, self.structured_jd)
        self.current_question = initial_question

        # Add question to interview data
        self.interview_data.append({
            "question": initial_question,
            "answer": None,
            "evaluation": None
        })

        return initial_question

    def add_answer(self, answer):
        """Add an answer to the current question"""
        # Store the answer
        self.interview_data[self.current_question_idx]["answer"] = answer

        # Generate expert answer for comparison
        expert_answer = generate_expert_answer(
            self.interview_data[self.current_question_idx]["question"],
            self.personal_profile
        )

        # Evaluate the answer
        evaluation = evaluate_answer(
            answer,
            expert_answer,
            self.interview_data[self.current_question_idx]["question"]
        )

        self.interview_data[self.current_question_idx]["evaluation"] = evaluation
        self.interview_data[self.current_question_idx]["expert_answer"] = expert_answer

        return expert_answer, evaluation

    def next_question(self):
        """Generate the next question based on the previous answer"""
        # Add the current question and answer to messages
        self.messages.append({"role": "assistant", "content": self.current_question})
        self.messages.append({"role": "user", "content": self.interview_data[self.current_question_idx]["answer"]})

        # Generate dynamic follow-up
        next_question = generate_dynamic_question(
            self.messages.copy(),
            self.interview_data[self.current_question_idx]["answer"],
            self.personal_profile
        )

        # Increment question index
        self.current_question_idx += 1

        # Store the new question
        self.current_question = next_question

        # Add question to interview data
        self.interview_data.append({
            "question": next_question,
            "answer": None,
            "evaluation": None
        })

        return next_question

    def get_interview_summary(self):
        """Generate a summary of the interview with feedback"""
        summary = get_interview_summary(self.interview_data)
        return summary

    def get_alignment_analysis(self):
        """Return the resume-job alignment analysis"""
        return self.alignment_analysis

#----------------------------------------
# MAIN INTERVIEW PROCESS FUNCTION
#----------------------------------------

def run_interview_process(resume_path, jd_path, num_questions=3):
    """Run a complete interview process from resume and job description"""
    print("\n===== INITIALIZING AI INTERVIEW PLATFORM =====\n")

    # Create interview session
    interview = InterviewSession(resume_path, jd_path)

    # Display resume-job alignment
    alignment = interview.get_alignment_analysis()
    print("\n===== RESUME-JOB ALIGNMENT ANALYSIS =====")
    print(f"Overall Match Score: {alignment['overall_match_score']}/100")
    print("\nStrengths:")
    for strength in alignment['strengths'][:3]:
        print(f"- {strength}")
    print("\nAreas of Concern:")
    for concern in alignment['areas_of_concern'][:3]:
        print(f"- {concern}")
    print("\nSuggested Interview Focus Areas:")
    for area in alignment['suggested_interview_focus_areas'][:3]:
        print(f"- {area}")

    # Start interview
    print("\n===== STARTING INTERVIEW =====\n")
    current_question = interview.start_interview()

    # Interview loop
    for i in range(num_questions):
        print(f"\n===== QUESTION {i+1} =====\n")
        print(current_question)
        print("\n")

        # Get user answer
        user_answer = input("Your Answer: ")

        # Process answer
        expert_answer, evaluation = interview.add_answer(user_answer)

        print("\n===== EVALUATION =====\n")
        print(evaluation)
        print("\n===== EXPERT ANSWER =====\n")
        print(expert_answer)

        # Generate next question if not the last one
        if i < num_questions - 1:
            current_question = interview.next_question()

    # Generate interview summary
    print("\n===== INTERVIEW SUMMARY =====\n")
    summary = interview.get_interview_summary()
    print(summary)

    print("\n===== INTERVIEW COMPLETED =====\n")

    # Return the interview session for any further processing
    return interview

interview = run_interview_process('/content/SourenduSahaResume.pdf', '/content/Grapefruit Health Data Analyst_Science Intern[78].pdf', num_questions=3)